var pe=e=>{throw TypeError(e)};var ve=(e,t,n)=>t.has(e)||pe("Cannot "+n);var i=(e,t,n)=>(ve(e,t,"read from private field"),n?n.call(e):t.get(e)),d=(e,t,n)=>t.has(e)?pe("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),c=(e,t,n,o)=>(ve(e,t,"write to private field"),o?o.call(e,n):t.set(e,n),n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))o(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&o(a)}).observe(document,{childList:!0,subtree:!0});function n(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function o(r){if(r.ep)return;r.ep=!0;const s=n(r);fetch(r.href,s)}})();var Ae=`#version 100
precision mediump float;

attribute vec2 a_position;
attribute vec3 a_color;
varying vec3 v_color;

uniform mat4 u_world;
uniform mat4 u_view;
uniform mat4 u_proj;

void main(){
  v_color = a_color;
  gl_Position = u_proj * u_view * u_world * vec4(a_position, 0.0, 1.0);
}`,ye=`#version 100
precision mediump float;

varying vec3 v_color;
uniform float u_time;

float map(float value, float inMin, float inMax, float outMin, float outMax) {
    return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
}

void main(){
  vec3 fragColor = v_color * map(sin(u_time * 4.0), -1.0, 1.0, 0.5, 1.0);
  gl_FragColor = vec4(fragColor, 1.0);
}`;const K="OES_vertex_array_object",X="ANGLE_instanced_arrays";var T=(e=>(e[e.WebGL1=0]="WebGL1",e[e.WebGL2=1]="WebGL2",e))(T||{}),G,v;class _e{constructor(t){d(this,G);d(this,v);c(this,G,t),c(this,v,new Map),t.version===0?(this.setExtension(K,this.retrieveExtension(t.gl,K)),this.setExtension(X,this.retrieveExtension(t.gl,X))):(this.setExtension(K,t.gl),this.setExtension(X,t.gl))}retrieveExtension(t,n){const o=t.getExtension(n);if(!o)return null;const r=n.split("_",1)[0],s=Object.getPrototypeOf(o),a=Object.fromEntries(Object.entries(s).map(([u,l])=>[u.replace(new RegExp(`_?${r}$`,"i"),""),typeof l=="function"?this.callWithContext(o,l):l]));return a.isExtension=!0,a}callWithContext(t,n){return(...o)=>n.call(t,...o)}getExtension(t){if(!i(this,v).has(t))throw new Error(`Missing WebGL extension: ${t}`);return i(this,v).get(t)}setExtension(t,n){n?i(this,v).set(t,n):i(this,v).delete(t)}get context(){return i(this,G)}get loadedExtensions(){return new Map([...i(this,v).entries()].filter(([t,n])=>n.isExtension))}get vertexArray(){return this.getExtension(K)}get instancedArrays(){return this.getExtension(X)}}G=new WeakMap,v=new WeakMap;var H,j;const B=class B{constructor(t){d(this,H);d(this,j);c(this,H,t),c(this,j,new _e(t))}static latest(t){const n=t.getContext("webgl2");if(n)return new B({version:T.WebGL2,gl:n});const o=t.getContext("webgl");if(o)return new B({version:T.WebGL1,gl:o});throw new Error("Failed to create WebGL wrapper: WebGL not supported")}static ofVersion(t,n){let o;switch(n){case T.WebGL1:o=t.getContext("webgl");break;case T.WebGL2:o=t.getContext("webgl2");break}if(!o)throw new Error("Failed to create WebGL wrapper: Version not supported");return new B({version:n,gl:o})}get context(){return i(this,H)}get ext(){return i(this,j)}};H=new WeakMap,j=new WeakMap;let re=B;var W,k,D;const Z=class Z{constructor(t,n,o){d(this,W);d(this,k);d(this,D);c(this,W,t),c(this,k,n),c(this,D,o)}static validBeforeDisposed(t,n){return new Z(t,0,n)}static validAfterDisposed(t,n){return new Z(t,1,n)}executeWhenValid(t){switch(i(this,k)){case 0:if(i(this,W).isDisposed)throw new Error("Invalid state: Already disposed");return t();case 1:if(!i(this,W).isDisposed)throw new Error("Invalid state: Not disposed");return t()}}get value(){return this.executeWhenValid(()=>i(this,D))}set value(t){this.executeWhenValid(()=>c(this,D,t))}};W=new WeakMap,k=new WeakMap,D=new WeakMap;let $=Z;var ne=(e=>(e[e.Vertex=0]="Vertex",e[e.Fragment=1]="Fragment",e))(ne||{}),L,O,Y,I;const ce=class ce{constructor(t,n,o){d(this,L);d(this,O);d(this,Y);d(this,I);c(this,O,t),c(this,Y,n);const r=t.context.gl,s=r.createShader(n===0?r.VERTEX_SHADER:r.FRAGMENT_SHADER);if(!s){const a=r.getError();throw new Error(`Failed to create shader (error code ${a})`)}if(r.shaderSource(s,o),r.compileShader(s),!r.getShaderParameter(s,r.COMPILE_STATUS)){const a=r.getError(),u=r.getShaderInfoLog(s);throw r.deleteShader(s),new Error(`Failed to compile shader (error code: ${a}): ${u}`)}c(this,I,$.validBeforeDisposed(this,s)),c(this,L,!1)}static create(t,n,o){return new ce(t,n,o)}get contextWrapper(){return i(this,O)}get type(){return i(this,Y)}get shader(){return i(this,I).value}get isDisposed(){return i(this,L)}dispose(){i(this,L)||(i(this,O).context.gl.deleteShader(i(this,I).value),c(this,L,!0))}};L=new WeakMap,O=new WeakMap,Y=new WeakMap,I=new WeakMap;let J=ce;var S,p,w,C,U,_,V;const he=class he{constructor(t,n,o){d(this,S);d(this,p);d(this,w);d(this,C);d(this,U);d(this,_);d(this,V);c(this,p,t);const r=t.context.gl,s=r.createProgram();if(!s){const l=r.getError();throw new Error(`Failed to create program (error code ${l})`)}if(r.attachShader(s,n.shader),r.attachShader(s,o.shader),r.linkProgram(s),!r.getProgramParameter(s,r.LINK_STATUS)){const l=r.getError(),h=r.getProgramInfoLog(s);throw r.deleteProgram(s),new Error(`Failed to link program (error code: ${l}): ${h}`)}c(this,_,new Map),c(this,V,new Map);const a=r.getProgramParameter(s,r.ACTIVE_UNIFORMS);for(let l=0;l<a;l++){const h=r.getActiveUniform(s,l),f=r.getUniformLocation(s,h.name);i(this,_).set(h.name,{name:h.name,size:h.size,type:h.type,location:f})}const u=r.getProgramParameter(s,r.ACTIVE_ATTRIBUTES);for(let l=0;l<u;l++){const h=r.getActiveAttrib(s,l),f=r.getAttribLocation(s,h.name);i(this,V).set(h.name,{name:h.name,size:h.size,type:h.type,location:f})}c(this,w,$.validBeforeDisposed(this,s)),c(this,C,n),c(this,U,o),c(this,S,!1)}static create(t,n,o){return new he(t,n,o)}use(){i(this,p).context.gl.useProgram(i(this,w).value)}setUniform(t,n){const o=i(this,p).context.gl,r=i(this,_).get(t);if(!r)throw new Error(`Unknown uniform: ${t}`);if(typeof n=="number")o.uniform1f(r.location,n);else if(Array.isArray(n)||n instanceof Float32Array)switch(n.length){case 2:o.uniform2fv(r.location,n);break;case 3:o.uniform3fv(r.location,n);break;case 4:o.uniform4fv(r.location,n);break;default:throw new Error(`Unsupported uniform array size: ${n.length}`)}}setUniformMatrix(t,n){const o=i(this,p).context.gl,r=i(this,_).get(t);if(!r)throw new Error(`Unknown uniform: ${t}`);switch(n.length){case 4:o.uniformMatrix2fv(r.location,!1,n);break;case 9:o.uniformMatrix3fv(r.location,!1,n);break;case 16:o.uniformMatrix4fv(r.location,!1,n);break;default:throw new Error(`Unsupported uniform matrix size: ${n.length}`)}}get contextWrapper(){return i(this,p)}get program(){return i(this,w).value}get vertexShader(){return i(this,C)}get fragmentShader(){return i(this,U)}get uniforms(){return i(this,_)}get attributes(){return i(this,V)}get isDisposed(){return i(this,S)}dispose(){i(this,S)||(i(this,p).context.gl.detachShader(i(this,w),i(this,C).shader),i(this,p).context.gl.detachShader(i(this,w),i(this,U).shader),i(this,p).context.gl.deleteProgram(i(this,w)),c(this,S,!0))}};S=new WeakMap,p=new WeakMap,w=new WeakMap,C=new WeakMap,U=new WeakMap,_=new WeakMap,V=new WeakMap;let ie=he;var se=(e=>(e[e.Array=0]="Array",e[e.Element=1]="Element",e))(se||{}),oe=(e=>(e[e.Static=0]="Static",e[e.Dynamic=1]="Dynamic",e[e.Stream=2]="Stream",e))(oe||{}),F,x,z,q,R;const le=class le{constructor(t,n,o){d(this,F);d(this,x);d(this,z);d(this,q);d(this,R);c(this,x,t),c(this,z,n),c(this,q,o);const r=t.context.gl.createBuffer();if(!r){const s=t.context.gl.getError();throw new Error(`Failed to create buffer object (error code: ${s})`)}c(this,R,$.validBeforeDisposed(this,r)),c(this,F,!1)}static create(t,n,o){return new le(t,n,o)}get target(){switch(i(this,z)){case 0:return i(this,x).context.gl.ARRAY_BUFFER;case 1:return i(this,x).context.gl.ELEMENT_ARRAY_BUFFER}}get usage(){switch(i(this,q)){case 0:return i(this,x).context.gl.STATIC_DRAW;case 1:return i(this,x).context.gl.DYNAMIC_DRAW;case 2:return i(this,x).context.gl.STREAM_DRAW}}bind(){const t=i(this,R).value;i(this,x).context.gl.bindBuffer(this.target,t)}unbind(){i(this,x).context.gl.bindBuffer(this.target,null)}setData(t){this.bind(),i(this,x).context.gl.bufferData(this.target,t,this.usage),this.unbind()}get contextWrapper(){return i(this,x)}get type(){return i(this,z)}get buffer(){return i(this,R).value}get isDisposed(){return i(this,F)}dispose(){i(this,F)||(i(this,x).context.gl.deleteBuffer(i(this,R)),c(this,F,!0))}};F=new WeakMap,x=new WeakMap,z=new WeakMap,q=new WeakMap,R=new WeakMap;let Q=le;var P,b,N;const de=class de{constructor(t){d(this,P);d(this,b);d(this,N);c(this,b,t);const n=t.ext.vertexArray.createVertexArray();if(!n){const o=t.context.gl.getError();throw new Error(`Failed to create VAO (error code ${o})`)}c(this,N,$.validBeforeDisposed(this,n)),c(this,P,!1)}static create(t){return new de(t)}bind(){i(this,b).ext.vertexArray.bindVertexArray(i(this,N).value)}unbind(){i(this,b).ext.vertexArray.bindVertexArray(null)}setAttribute(t,n,o,r,s,a){this.bind(),n.bind();const u=i(this,b).context.gl;u.enableVertexAttribArray(t),u.vertexAttribPointer(t,o,r,!1,s,a),n.unbind(),this.unbind()}bindElementBuffer(t){this.bind(),t.bind(),this.unbind()}get contextWrapper(){return i(this,b)}get vao(){return i(this,N).value}get isDisposed(){return i(this,P)}dispose(){i(this,P)||(i(this,b).ext.vertexArray.deleteVertexArray(i(this,N).value),c(this,P,!0))}};P=new WeakMap,b=new WeakMap,N=new WeakMap;let ae=de;var ee=1e-6,we=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});function te(){var e=new we(16);return we!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function Me(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Le(e,t,n,o,r,s,a){var u=1/(t-n),l=1/(o-r),h=1/(s-a);return e[0]=-2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*h,e[11]=0,e[12]=(t+n)*u,e[13]=(r+o)*l,e[14]=(a+s)*h,e[15]=1,e}var be=Le;function Se(e,t,n,o){var r,s,a,u,l,h,f,m,E,g,A=t[0],M=t[1],y=t[2],ue=o[0],ge=o[1],fe=o[2],xe=n[0],me=n[1],Ee=n[2];return Math.abs(A-xe)<ee&&Math.abs(M-me)<ee&&Math.abs(y-Ee)<ee?Me(e):(f=A-xe,m=M-me,E=y-Ee,g=1/Math.hypot(f,m,E),f*=g,m*=g,E*=g,r=ge*E-fe*m,s=fe*f-ue*E,a=ue*m-ge*f,g=Math.hypot(r,s,a),g?(g=1/g,r*=g,s*=g,a*=g):(r=0,s=0,a=0),u=m*a-E*s,l=E*r-f*a,h=f*s-m*r,g=Math.hypot(u,l,h),g?(g=1/g,u*=g,l*=g,h*=g):(u=0,l=0,h=0),e[0]=r,e[1]=u,e[2]=f,e[3]=0,e[4]=s,e[5]=l,e[6]=m,e[7]=0,e[8]=a,e[9]=h,e[10]=E,e[11]=0,e[12]=-(r*A+s*M+a*y),e[13]=-(u*A+l*M+h*y),e[14]=-(f*A+m*M+E*y),e[15]=1,e)}function Fe(e){const t=re.ofVersion(e,T.WebGL1),n=t.context.gl,o=()=>{let r=!1;const s=e.clientWidth,a=e.clientHeight;(e.width!==s||e.height!==a)&&(e.width=s,e.height=a,r=!0),r&&n.viewport(0,0,e.width,e.height)};return window.addEventListener("resize",o),o(),console.log("Loaded WebGL version:",n.getParameter(n.VERSION)),console.log("Loaded extensions:",[...t.ext.loadedExtensions.keys()]),t}function Re(e){const t=e.context.gl,n=J.create(e,ne.Vertex,Ae),o=J.create(e,ne.Fragment,ye),r=ie.create(e,n,o),s=new Float32Array([0,0,.5,.5,.5,0,1,1,0,0,-.866,.5,1,0,1,-.866,-.5,0,0,1,0,-1,0,1,1,.866,-.5,0,1,0,.866,.5,1,1,0]),a=new Int16Array([0,1,2,3,4,5,6,1]),u=Q.create(e,se.Array,oe.Static),l=Q.create(e,se.Element,oe.Static);u.setData(s),l.setData(a);const h=ae.create(e);h.setAttribute(0,u,2,t.FLOAT,5*s.BYTES_PER_ELEMENT,0*s.BYTES_PER_ELEMENT),h.setAttribute(1,u,3,t.FLOAT,5*s.BYTES_PER_ELEMENT,2*s.BYTES_PER_ELEMENT),h.bindElementBuffer(l);let f=t.canvas.width/t.canvas.height;const m=te(),E=Se(te(),[0,0,1],[0,0,0],[0,1,0]),g=be(te(),-f,f,-1,1,-1,1);r.use(),r.setUniformMatrix("u_world",m),r.setUniformMatrix("u_view",E),r.setUniformMatrix("u_proj",g),t.enable(t.CULL_FACE),t.cullFace(t.BACK);function A(M){t.clear(t.COLOR_BUFFER_BIT),r.use(),r.setUniform("u_time",M/1e3);const y=t.canvas.width/t.canvas.height;f!==y&&(f=y,r.setUniformMatrix("u_proj",be(g,-f,f,-1,1,-1,1))),h.bind(),t.drawElements(t.TRIANGLE_FAN,a.length,t.UNSIGNED_SHORT,0),h.unbind(),requestAnimationFrame(A)}A(0)}function Pe(){const e=document.getElementById("cnv"),t=Fe(e);Re(t)}Pe();
