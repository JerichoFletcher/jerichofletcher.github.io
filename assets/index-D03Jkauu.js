var _t=t=>{throw TypeError(t)};var bt=(t,e,r)=>e.has(t)||_t("Cannot "+r);var i=(t,e,r)=>(bt(t,e,"read from private field"),r?r.call(t):e.get(t)),l=(t,e,r)=>e.has(t)?_t("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,r),a=(t,e,r,s)=>(bt(t,e,"write to private field"),s?s.call(t,r):e.set(t,r),r);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const o of n)if(o.type==="childList")for(const c of o.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&s(c)}).observe(document,{childList:!0,subtree:!0});function r(n){const o={};return n.integrity&&(o.integrity=n.integrity),n.referrerPolicy&&(o.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?o.credentials="include":n.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(n){if(n.ep)return;n.ep=!0;const o=r(n);fetch(n.href,o)}})();var Ot=`#version 100
precision mediump float;

attribute vec3 a_position;
attribute vec3 a_color;

varying vec3 v_color;

uniform mat4 u_world;
uniform mat4 u_view;
uniform mat4 u_proj;

void main(){
  v_color = a_color;
  gl_Position = u_proj * u_view * u_world * vec4(a_position, 1.0);
}`,Mt=`#version 100
precision mediump float;

varying vec3 v_color;

uniform float u_time;

const float th3 = 1.0 / 3.0;
const float sq3 = sqrt(th3);

float map(float value, float inMin, float inMax, float outMin, float outMax){
  return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
}

vec3 color_shift(vec3 color, float angle){
  float cosA = cos(angle);
  float sinA = sin(angle);

  mat3 m = mat3(
    cosA + th3 * (1.0 - cosA), th3 * (1.0 - cosA) - sq3 * sinA, th3 * (1.0 - cosA) + sq3 * sinA,
    th3 * (1.0 - cosA) + sq3 * sinA, cosA + th3 * (1.0 - cosA), th3 * (1.0 - cosA) - sq3 * sinA,
    th3 * (1.0 - cosA) - sq3 * sinA, th3 * (1.0 - cosA) + sq3 * sinA, cosA + th3 * (1.0 - cosA)
  );

  return clamp(m * color, vec3(0.0), vec3(1.0));
}

void main(){
  float shiftAngle = u_time * -3.0;
  gl_FragColor = vec4(color_shift(v_color, shiftAngle), 1.0);
}`;const et="OES_vertex_array_object",nt="ANGLE_instanced_arrays";var C=(t=>(t[t.WebGL1=0]="WebGL1",t[t.WebGL2=1]="WebGL2",t))(C||{}),p,w;class Nt{constructor(e){l(this,p);l(this,w);a(this,p,e),a(this,w,new Map),e.version===0?(this.setExtension(et,this.retrieveExtension(e.gl,et)),this.setExtension(nt,this.retrieveExtension(e.gl,nt))):(this.setExtension(et,e.gl),this.setExtension(nt,e.gl))}retrieveExtension(e,r){const s=e.getExtension(r);if(!s)return null;const n=r.split("_",1)[0],o=Object.getPrototypeOf(s);return{...Object.fromEntries(Object.entries(o).map(([c,f])=>[c.replace(new RegExp(`_?${n}$`,"i"),""),typeof f=="function"?this.callWithContext(s,f):f])),isExtension:!0}}callWithContext(e,r){return(...s)=>r.call(e,...s)}getExtension(e){if(!i(this,w).has(e))throw new Error(`Missing WebGL extension: ${e}`);return i(this,w).get(e)}setExtension(e,r){r?i(this,w).set(e,r):i(this,w).delete(e)}get context(){return i(this,p)}get loadedExtensions(){return new Map([...i(this,w).entries()].filter(([,e])=>e.isExtension))}get vertexArray(){return this.getExtension(et)}get instancedArrays(){return this.getExtension(nt)}}p=new WeakMap,w=new WeakMap;var K,X;const j=class j{constructor(e){l(this,K);l(this,X);a(this,K,e),a(this,X,new Nt(e))}static latest(e){const r=e.getContext("webgl2");if(r)return new j({version:C.WebGL2,gl:r});const s=e.getContext("webgl");if(s)return new j({version:C.WebGL1,gl:s});throw new Error("Failed to create WebGL wrapper: WebGL not supported")}static ofVersion(e,r){let s;switch(r){case C.WebGL1:s=e.getContext("webgl");break;case C.WebGL2:s=e.getContext("webgl2");break}if(!s)throw new Error("Failed to create WebGL wrapper: Version not supported");return new j({version:r,gl:s})}get context(){return i(this,K)}get funcs(){return i(this,X)}};K=new WeakMap,X=new WeakMap;let at=j;var P,Z,D;const it=class it{constructor(e,r,s){l(this,P);l(this,Z);l(this,D);a(this,P,e),a(this,Z,r),a(this,D,s)}static validBeforeDisposed(e,r){return new it(e,0,r)}static validAfterDisposed(e,r){return new it(e,1,r)}executeWhenValid(e){switch(i(this,Z)){case 0:if(i(this,P).isDisposed)throw new Error("Invalid state: Already disposed");return e();case 1:if(!i(this,P).isDisposed)throw new Error("Invalid state: Not disposed");return e()}}get value(){return this.executeWhenValid(()=>i(this,D))}set value(e){this.executeWhenValid(()=>a(this,D,e))}};P=new WeakMap,Z=new WeakMap,D=new WeakMap;let k=it;function St(t,e){switch(e){case t.context.gl.FLOAT:case t.context.gl.UNSIGNED_BYTE:case t.context.gl.UNSIGNED_SHORT:case t.context.gl.UNSIGNED_INT:case t.context.gl.BYTE:case t.context.gl.SHORT:case t.context.gl.INT:case t.context.gl.BOOL:return 1;case t.context.gl.FLOAT_VEC2:case t.context.gl.INT_VEC2:case t.context.gl.BOOL_VEC2:return 2;case t.context.gl.FLOAT_VEC3:case t.context.gl.INT_VEC3:case t.context.gl.BOOL_VEC3:return 3;case t.context.gl.FLOAT_VEC4:case t.context.gl.INT_VEC4:case t.context.gl.BOOL_VEC4:case t.context.gl.FLOAT_MAT2:return 4;case t.context.gl.FLOAT_MAT3:return 9;case t.context.gl.FLOAT_MAT4:return 16;default:throw new Error(`Unknown GL type: ${e}`)}}function Ft(t,e){switch(e){case t.context.gl.FLOAT_VEC2:case t.context.gl.FLOAT_VEC3:case t.context.gl.FLOAT_VEC4:case t.context.gl.FLOAT_MAT2:case t.context.gl.FLOAT_MAT3:case t.context.gl.FLOAT_MAT4:return t.context.gl.FLOAT;case t.context.gl.BOOL_VEC2:case t.context.gl.BOOL_VEC3:case t.context.gl.BOOL_VEC4:return t.context.gl.BOOL;case t.context.gl.INT_VEC2:case t.context.gl.INT_VEC3:case t.context.gl.INT_VEC4:return t.context.gl.INT;case t.context.gl.BYTE:case t.context.gl.SHORT:case t.context.gl.INT:case t.context.gl.UNSIGNED_BYTE:case t.context.gl.UNSIGNED_SHORT:case t.context.gl.UNSIGNED_INT:case t.context.gl.FLOAT:case t.context.gl.BOOL:return e;default:throw new Error(`Unknown GL type: ${e}`)}}function Lt(t,e){const r=St(t,e.type),s=Ft(t,e.type);return{name:e.name,size:e.size,type:e.type,elementSize:r,elementType:s}}function It(t,e,r){return{...Lt(t,e),location:r}}function Vt(t,e,r){return{...Lt(t,e),location:r}}var ht=(t=>(t[t.Vertex=0]="Vertex",t[t.Fragment=1]="Fragment",t))(ht||{}),O,U,J,G;const gt=class gt{constructor(e,r,s){l(this,O);l(this,U);l(this,J);l(this,G);a(this,U,e),a(this,J,r);const n=e.context.gl,o=n.createShader(r===0?n.VERTEX_SHADER:n.FRAGMENT_SHADER);if(!o){const c=n.getError();throw new Error(`Failed to create shader (error code ${c})`)}if(n.shaderSource(o,s),n.compileShader(o),!n.getShaderParameter(o,n.COMPILE_STATUS)){const c=n.getError(),f=n.getShaderInfoLog(o);throw n.deleteShader(o),new Error(`Failed to compile shader (error code: ${c}): ${f}`)}a(this,G,k.validBeforeDisposed(this,o)),a(this,O,!1)}static create(e,r,s){return new gt(e,r,s)}get contextWrapper(){return i(this,U)}get type(){return i(this,J)}get shader(){return i(this,G).value}get isDisposed(){return i(this,O)}dispose(){i(this,O)||(i(this,U).context.gl.deleteShader(i(this,G).value),a(this,O,!0))}};O=new WeakMap,U=new WeakMap,J=new WeakMap,G=new WeakMap;let rt=gt;var M,A,_,$,z,L,H;const xt=class xt{constructor(e,r,s){l(this,M);l(this,A);l(this,_);l(this,$);l(this,z);l(this,L);l(this,H);a(this,A,e);const n=e.context.gl,o=n.createProgram();if(!o){const h=n.getError();throw new Error(`Failed to create program (error code ${h})`)}if(n.attachShader(o,r.shader),n.attachShader(o,s.shader),n.linkProgram(o),!n.getProgramParameter(o,n.LINK_STATUS)){const h=n.getError(),u=n.getProgramInfoLog(o);throw n.deleteProgram(o),new Error(`Failed to link program (error code: ${h}): ${u}`)}a(this,L,new Map),a(this,H,new Map);const c=n.getProgramParameter(o,n.ACTIVE_UNIFORMS);for(let h=0;h<c;h++){const u=n.getActiveUniform(o,h),g=n.getUniformLocation(o,u.name);i(this,L).set(u.name,It(e,u,g))}const f=n.getProgramParameter(o,n.ACTIVE_ATTRIBUTES);for(let h=0;h<f;h++){const u=n.getActiveAttrib(o,h),g=n.getAttribLocation(o,u.name);i(this,H).set(u.name,Vt(e,u,g))}a(this,_,k.validBeforeDisposed(this,o)),a(this,$,r),a(this,z,s),a(this,M,!1)}static create(e,r,s){return new xt(e,r,s)}bind(){i(this,A).context.gl.useProgram(i(this,_).value)}unbind(){i(this,A).context.gl.useProgram(null)}setUniform(e,r){const s=i(this,A).context.gl,n=i(this,L).get(e);if(!n)throw new Error(`Unknown uniform: ${e}`);if(typeof r=="number")s.uniform1f(n.location,r);else if(Array.isArray(r)||r instanceof Float32Array)switch(r.length){case 2:s.uniform2fv(n.location,r);break;case 3:s.uniform3fv(n.location,r);break;case 4:s.uniform4fv(n.location,r);break;default:throw new Error(`Unsupported uniform array size: ${r.length}`)}}setUniformMatrix(e,r){const s=i(this,A).context.gl,n=i(this,L).get(e);if(!n)throw new Error(`Unknown uniform: ${e}`);switch(r.length){case 4:s.uniformMatrix2fv(n.location,!1,r);break;case 9:s.uniformMatrix3fv(n.location,!1,r);break;case 16:s.uniformMatrix4fv(n.location,!1,r);break;default:throw new Error(`Unsupported uniform matrix size: ${r.length}`)}}get contextWrapper(){return i(this,A)}get program(){return i(this,_).value}get vertexShader(){return i(this,$)}get fragmentShader(){return i(this,z)}get uniforms(){return i(this,L)}get attributes(){return i(this,H)}get isDisposed(){return i(this,M)}dispose(){i(this,M)||(i(this,A).context.gl.detachShader(i(this,_),i(this,$).shader),i(this,A).context.gl.detachShader(i(this,_),i(this,z).shader),i(this,A).context.gl.deleteProgram(i(this,_)),a(this,M,!0))}};M=new WeakMap,A=new WeakMap,_=new WeakMap,$=new WeakMap,z=new WeakMap,L=new WeakMap,H=new WeakMap;let lt=xt;function B(t,e){try{for(const r of t)r.bind();return e()}finally{for(let r=t.length-1;r>=0;r--)t[r].unbind()}}var ft=(t=>(t[t.Array=0]="Array",t[t.Element=1]="Element",t))(ft||{}),ut=(t=>(t[t.Static=0]="Static",t[t.Dynamic=1]="Dynamic",t[t.Stream=2]="Stream",t))(ut||{}),N,m,Y,Q,S;const Et=class Et{constructor(e,r,s){l(this,N);l(this,m);l(this,Y);l(this,Q);l(this,S);a(this,m,e),a(this,Y,r),a(this,Q,s);const n=e.context.gl.createBuffer();if(!n){const o=e.context.gl.getError();throw new Error(`Failed to create buffer object (error code: ${o})`)}a(this,S,k.validBeforeDisposed(this,n)),a(this,N,!1)}static create(e,r,s){return new Et(e,r,s)}get target(){switch(i(this,Y)){case 0:return i(this,m).context.gl.ARRAY_BUFFER;case 1:return i(this,m).context.gl.ELEMENT_ARRAY_BUFFER}}get usage(){switch(i(this,Q)){case 0:return i(this,m).context.gl.STATIC_DRAW;case 1:return i(this,m).context.gl.DYNAMIC_DRAW;case 2:return i(this,m).context.gl.STREAM_DRAW}}bind(){const e=i(this,S).value;i(this,m).context.gl.bindBuffer(this.target,e)}unbind(){i(this,m).context.gl.bindBuffer(this.target,null)}setData(e){B([this],()=>i(this,m).context.gl.bufferData(this.target,e,this.usage))}get contextWrapper(){return i(this,m)}get type(){return i(this,Y)}get buffer(){return i(this,S).value}get isDisposed(){return i(this,N)}dispose(){i(this,N)||(i(this,m).context.gl.deleteBuffer(i(this,S)),a(this,N,!0))}};N=new WeakMap,m=new WeakMap,Y=new WeakMap,Q=new WeakMap,S=new WeakMap;let st=Et;var F,v,I;const mt=class mt{constructor(e){l(this,F);l(this,v);l(this,I);a(this,v,e);const r=e.funcs.vertexArray.createVertexArray();if(!r){const s=e.context.gl.getError();throw new Error(`Failed to create VAO (error code ${s})`)}a(this,I,k.validBeforeDisposed(this,r)),a(this,F,!1)}static create(e){return new mt(e)}bind(){i(this,v).funcs.vertexArray.bindVertexArray(i(this,I).value)}unbind(){i(this,v).funcs.vertexArray.bindVertexArray(null)}setAttribute(e,r,s,n,o,c,f){B([this,r],()=>{const h=i(this,v).context.gl;h.enableVertexAttribArray(e),h.vertexAttribPointer(e,s,n,o,c,f)})}bindElementBuffer(e){B([this],()=>e.bind()),e.unbind()}drawElements(e,r,s,n){B([this],()=>i(this,v).context.gl.drawElements(e,r,s,n))}get contextWrapper(){return i(this,v)}get vao(){return i(this,I).value}get isDisposed(){return i(this,F)}dispose(){i(this,F)||(i(this,v).funcs.vertexArray.deleteVertexArray(i(this,I).value),a(this,F,!0))}};F=new WeakMap,v=new WeakMap,I=new WeakMap;let dt=mt;var ot=1e-6,yt=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});function ct(){var t=new yt(16);return yt!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function Rt(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Ct(t,e,r){var s=Math.sin(r),n=Math.cos(r),o=e[0],c=e[1],f=e[2],h=e[3],u=e[4],g=e[5],x=e[6],E=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=o*n+u*s,t[1]=c*n+g*s,t[2]=f*n+x*s,t[3]=h*n+E*s,t[4]=u*n-o*s,t[5]=g*n-c*s,t[6]=x*n-f*s,t[7]=E*n-h*s,t}function Bt(t,e,r,s,n,o,c){var f=1/(e-r),h=1/(s-n),u=1/(o-c);return t[0]=-2*f,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*h,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*u,t[11]=0,t[12]=(e+r)*f,t[13]=(n+s)*h,t[14]=(c+o)*u,t[15]=1,t}var Tt=Bt;function Pt(t,e,r,s){var n,o,c,f,h,u,g,x,E,d,b=e[0],y=e[1],T=e[2],R=s[0],tt=s[1],q=s[2],At=r[0],vt=r[1],wt=r[2];return Math.abs(b-At)<ot&&Math.abs(y-vt)<ot&&Math.abs(T-wt)<ot?Rt(t):(g=b-At,x=y-vt,E=T-wt,d=1/Math.hypot(g,x,E),g*=d,x*=d,E*=d,n=tt*E-q*x,o=q*g-R*E,c=R*x-tt*g,d=Math.hypot(n,o,c),d?(d=1/d,n*=d,o*=d,c*=d):(n=0,o=0,c=0),f=x*c-E*o,h=E*n-g*c,u=g*o-x*n,d=Math.hypot(f,h,u),d?(d=1/d,f*=d,h*=d,u*=d):(f=0,h=0,u=0),t[0]=n,t[1]=f,t[2]=g,t[3]=0,t[4]=o,t[5]=h,t[6]=x,t[7]=0,t[8]=c,t[9]=u,t[10]=E,t[11]=0,t[12]=-(n*b+o*y+c*T),t[13]=-(f*b+h*y+u*T),t[14]=-(g*b+x*y+E*T),t[15]=1,t)}var W,V;class Dt{constructor(e){l(this,W);l(this,V);a(this,W,e),a(this,V,new Map)}setAttribute(...e){for(const r of e)i(this,V).set(r.attribName,r)}configure(e,r){for(const s of r.attributes.values()){const n=i(this,V).get(s.name);if(!n)throw new Error(`Attribute ${s.name} not defined by the layout`);e.setAttribute(s.location,n.targetBuffer,s.elementSize,s.elementType,n.normalized??!1,n.stride,n.offset)}}get contextWrapper(){return i(this,W)}get configs(){return i(this,V)}}W=new WeakMap,V=new WeakMap;function Ut(t){const e=at.ofVersion(t,C.WebGL1),r=e.context.gl,s=()=>{let n=!1;const o=t.clientWidth,c=t.clientHeight;(t.width!==o||t.height!==c)&&(t.width=o,t.height=c,n=!0),n&&r.viewport(0,0,t.width,t.height)};return window.addEventListener("resize",s),s(),console.log("Loaded WebGL version:",r.getParameter(r.VERSION)),console.log("Loaded extensions:",[...e.funcs.loadedExtensions.keys()]),e}function Gt(t){const e=t.context.gl,r=rt.create(t,ht.Vertex,Ot),s=rt.create(t,ht.Fragment,Mt),n=lt.create(t,r,s),o=new Float32Array([0,0,0,.7,.7,.7,0,1,0,1,0,0,-.866,.5,0,.7,0,.7,-.866,-.5,0,0,0,1,0,-1,0,0,.7,.7,.866,-.5,0,0,1,0,.866,.5,0,.7,.7,0]),c=new Int16Array([0,1,2,3,4,5,6,1]),f=st.create(t,ft.Array,ut.Static),h=st.create(t,ft.Element,ut.Static);f.setData(o),h.setData(c);const u=dt.create(t),g=new Dt(t);g.setAttribute({attribName:"a_position",targetBuffer:f,stride:6*o.BYTES_PER_ELEMENT,offset:0*o.BYTES_PER_ELEMENT},{attribName:"a_color",targetBuffer:f,stride:6*o.BYTES_PER_ELEMENT,offset:3*o.BYTES_PER_ELEMENT}),g.configure(u,n),u.bindElementBuffer(h);let x=e.canvas.width/e.canvas.height;const E=ct(),d=Pt(ct(),[0,0,1],[0,0,0],[0,1,0]),b=Tt(ct(),-x,x,-1,1,0,1e3);B([n],()=>{n.setUniformMatrix("u_world",E),n.setUniformMatrix("u_view",d),n.setUniformMatrix("u_proj",b)});let y=0;function T(R){e.clear(e.COLOR_BUFFER_BIT),B([n],()=>{n.setUniform("u_time",R/1e3);const tt=y-R;n.setUniformMatrix("u_world",Ct(E,E,tt*Math.PI/2e3));const q=e.canvas.width/e.canvas.height;x!==q&&(x=q,n.setUniformMatrix("u_proj",Tt(b,-x,x,-1,1,-1,1))),u.drawElements(e.TRIANGLE_FAN,c.length,e.UNSIGNED_SHORT,0)}),y=R,requestAnimationFrame(T)}T(0)}function $t(){const t=document.getElementById("cnv"),e=Ut(t);Gt(e)}$t();
